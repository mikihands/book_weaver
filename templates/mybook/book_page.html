{% extends "page_base.html" %}
{% load static tailwind_tags i18n %}
{% load weaver_extras %}
{% block title %} {{ book.title }} - p{{ page_no }} {% endblock %}

{% block additional_head %}
<style>
  :root { --bg:#f9fafb; --ink:#111827; --muted:#6b7280; --top-margin: {{ css_vars|dict_get:'--top-margin' }}; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;}

  .wrap{max-width:100vw;margin:0 auto;padding:16px;}
  .toolbar{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap}
  .toolbar .group{display:flex;gap:8px;align-items:center}
  .toolbar button, .toolbar select{
    font:inherit;padding:6px 10px;border:1px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer}
  .toolbar button.active {
    background-color: #eef2ff; /* indigo-50 */
    border-color: #a5b4fc; /* indigo-200 */
    color: #4338ca; /* indigo-800 */
    font-weight: 600;
  }
  .toolbar button:hover{background:#f3f4f6}

  .stage{
    position:relative;
    overflow:auto;
    max-height: calc(100vh - 140px);
    display: flex;
    justify-content: center;
    align-items: flex-start; /* 페이지를 상단에 정렬 */
    padding: 20px 0; /* 뷰어의 상하 여백 */
  }
  .split-view {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    align-items: flex-start;
  }
  .pdf-viewer-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
    height: 100%;
    overflow: auto;
    padding: 20px 0;
  }
  #original-page-image {
    border: 1px solid #e5e7eb;
    max-width: 100%;
  }
  .page-viewport {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,.06);
    padding: 12px;
    box-sizing: border-box; /* padding을 너비/높이에 포함 */
    flex-shrink: 0; /* flex 아이템이 줄어들지 않도록 설정 */
  }

  .page{
    position:relative;
    width:{{ page_w }}px;
    height:{{ page_h }}px;
    transform-origin: top left;
  }

  /* v2 HTML stage 내부 기본 타이포 */
  .page :is(p,li){line-height:1.5}
  figure{margin:0.5rem 0;display:flex;flex-direction:column}
  figure img{max-width:100%;height:auto;border:1px solid #e5e7eb;border-radius:6px;background:#fff}
  figure figcaption{margin-top:.4rem;font-size:.9rem;color:var(--muted)}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #e5e7eb;padding:.5rem;vertical-align:top}

  .content div, .content p, .content div p {
      line-height: var(--leading);  
      margin-bottom: var(--para-gap);
  }
  .content {
    
    font-size: var(--font-base);
    padding: var(--pad);
    width: var(--content-w);
    height: var(--content-h);
    margin: 0 auto;
    padding-top: var(--top-margin);
  }
    
</style>
{% endblock %}

{% block content %}
<div id="translation-container" class="content" 
    style="
    --font-base: {{ css_vars|dict_get:'--font-base' }};
    --leading: {{ css_vars|dict_get:'--leading' }};
    --para-gap: {{ css_vars|dict_get:'--para-gap' }};
    --content-w: {{ css_vars|dict_get:'--content-w' }};
    --content-h: {{ css_vars|dict_get:'--content-h' }};
    --pad: {{ css_vars|dict_get:'--pad' }};
">
  {{ html_stage_final|safe }}
</div>

<div id="originalPane" class="d-none">
    <img id="origImg" alt="원본 페이지" style="max-width:100%;height:auto;border:1px solid #e5e7eb;border-radius:8px;">
</div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  const pageW = {{ page_w|default:800 }};
  const pageH = {{ page_h|default:1200 }};
  const stage  = document.getElementById('stage');
  if (!stage) return;
  const vp    = document.getElementById('pageViewport');
  const page   = document.getElementById('page');
  const zoomLabel = document.getElementById('zoomLabel');
  const fitWBtn = document.getElementById('fitW');
  const fitHBtn = document.getElementById('fitH');
  const zoomIn  = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');

  let scale = 1.0;
  let zoomMode = 'fitWidth'; // 'fitWidth', 'fitHeight', 'custom' 중 하나를 저장
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const ZOOM_STATE_KEY = 'weaver_zoom_state'; // localStorage에 저장될 키

  // 현재 확대/축소 상태(비율과 모드)를 저장하는 함수
  function saveZoomState() {
    const state = { scale: scale, mode: zoomMode };
    localStorage.setItem(ZOOM_STATE_KEY, JSON.stringify(state));
  }

  function applyScale(newScale) {
    scale = clamp(newScale, 0.2, 3);
    page.style.transform = `scale(${scale})`;
    zoomLabel.textContent = Math.round(scale*100) + '%';

    const viewportPadding = 24;
    const scaledW = pageW * scale;
    const scaledH = pageH * scale;

    vp.style.width  = (scaledW + viewportPadding) + 'px';
    vp.style.height = (scaledH + viewportPadding) + 'px';
    stage.style.height = (scaledH + viewportPadding) + 'px';

    // 스케일이 적용될 때마다 상태를 저장합니다.
    saveZoomState();
  }
  
  function fitWidth(){
    zoomMode = 'fitWidth';
    const viewportPadding = 24;
    const availableWidth = stage.clientWidth;
    applyScale((availableWidth - viewportPadding) / pageW);
  }
  function fitHeight(){
    zoomMode = 'fitHeight';
    const pad = 24*2;
    const avail = (window.innerHeight - stage.getBoundingClientRect().top - 40) - pad;
    applyScale(avail / pageH);
  }

  fitWBtn.addEventListener('click', fitWidth);
  fitHBtn.addEventListener('click', fitHeight);
  zoomIn.addEventListener('click', () => {
    zoomMode = 'custom'; // 사용자가 직접 조절했음을 표시
    applyScale(scale * 1.1);
  });
  zoomOut.addEventListener('click', () => {
    zoomMode = 'custom'; // 사용자가 직접 조절했음을 표시
    applyScale(scale / 1.1);
  });
  window.addEventListener('resize', () => {
    // '가로 맞춤' 상태일 때만 창 크기 변경에 따라 너비를 다시 맞춥니다.
    if (zoomMode === 'fitWidth') {
      fitWidth();
    }
  });

  // 초기 뷰 설정: 저장된 확대/축소 상태가 있으면 복원합니다.
  (function initializeView() {
    try {
      const savedStateJSON = localStorage.getItem(ZOOM_STATE_KEY);
      if (savedStateJSON) {
          const savedState = JSON.parse(savedStateJSON);
          if (savedState && savedState.mode) {
              zoomMode = savedState.mode;
              if (zoomMode === 'fitWidth') { fitWidth(); return; }
              if (zoomMode === 'fitHeight') { fitHeight(); return; }
              if (zoomMode === 'custom' && typeof savedState.scale === 'number') { applyScale(savedState.scale); return; }
          }
      }
    } catch (e) {
      console.error("Failed to restore zoom state, using default.", e);
      localStorage.removeItem(ZOOM_STATE_KEY); // 손상된 데이터 제거
    }
    // 저장된 상태가 없거나 유효하지 않으면 기본값으로 시작합니다.
    fitWidth();
  })();
})();
</script>

<script>
/**
 * 원본보기 / 함께보기 (Option B: 페이지 이미지 캐싱, '2개의 독립 뷰포트' 버전)
 * - 번역본: #translation-container (기존 그대로, #pageViewport 안)
 * - 원본:   #originalPane (초기엔 #page 안에 있지만, JS가 #origViewport/#origPage로 이동시킴)
 * - 버튼:   #btnToggleOriginal, #btnSideBySide
 * - 뷰모드: 'translated' | 'original' | 'sbs'
 *
 * 핵심 아이디어:
 *  1) #pageViewport는 번역본 전용, #origViewport(동적 생성)는 원본 전용으로 분리
 *  2) '함께보기'에서는 #stage를 flex 컨테이너로 만들어 두 뷰포트를 나란히 배치
 *  3) 확대/축소는 기존 #page에 걸린 transform을 관찰하여 #origPage에 그대로 복제
 */
(function(){
  // -------- 필수 DOM --------
  const btnToggleOriginal = document.getElementById('btnToggleOriginal');
  const btnSideBySide     = document.getElementById('btnSideBySide');
  const translatedPane    = document.getElementById('translation-container');
  const originalPane      = document.getElementById('originalPane');
  const origImg           = document.getElementById('origImg');
  const pageEl            = document.getElementById('page');          // (확대/축소 transform 대상)
  const pageViewport      = document.getElementById('pageViewport');  // 번역본 뷰포트
  const stageEl           = document.getElementById('stage');         // 스크롤/레이아웃 컨테이너

  if (!btnToggleOriginal || !btnSideBySide || !translatedPane || !originalPane || !origImg || !pageEl || !pageViewport || !stageEl) {
    return;
  }

  // -------- 서버에서 내려주는 값(뷰 컨텍스트) --------
  const bookId = {{ book.id }};
  const pageNo = {{ page_no }};

  // 원본 이미지 URL (mybook:original_page_image)
  const ORIGINAL_IMG_ENDPOINT = "{% url 'mybook:original_page_image' book.id 1 %}".replace(/1\/original-image\/$/, pageNo + "/original-image/");

  // -------- 상태 --------
  let mode = 'translated'; // 'translated' | 'original' | 'sbs'
  let originalLoaded = false;

  // -------- 동적으로 '두 번째 뷰포트' 만들기 --------
  //  <div id="origViewport" class="page-viewport">
  //    <div id="origPage" class="page">
  //       (originalPane 가 여기로 이동됨)
  //    </div>
  //  </div>
  let origViewport = document.getElementById('origViewport');
  let origPage = document.getElementById('origPage');

  function ensureOrigViewport() {
    if (!origViewport) {
      origViewport = document.createElement('div');
      origViewport.id = 'origViewport';
      origViewport.className = 'page-viewport';
      // 번역본 뷰포트와 비슷한 느낌(배경/테두리)으로 가볍게 스타일
      Object.assign(origViewport.style, {
        // page_base.css의 .page-viewport와 시각적으로 어울리도록 최소한만 지정
        background: '#fff',
        border: '1px solid #e5e7eb',
        borderRadius: '12px',
        overflow: 'hidden',
      });
    }
    if (!origPage) {
      origPage = document.createElement('div');
      origPage.id = 'origPage';
      origPage.className = 'page';
      // #page와 동일하게 transform이 적용될 대상
      origViewport.appendChild(origPage);
    }
    if (!originalPane.parentElement || originalPane.parentElement.id !== 'origPage') {
      origPage.appendChild(originalPane); // 원본 패널을 두 번째 페이지 안으로 이동
    }
    // stage의 끝에 붙여두되, 기본은 숨김(모드 전환 때 보이게)
    if (!origViewport.parentElement) {
      stageEl.appendChild(origViewport);
    }
  }

  // -------- 유틸 (null-safe) --------
  function show(el){
    if (!el) return;
    if (el.classList) el.classList.remove('hidden', 'd-none');
    el.style && (el.style.display = '');
  }
  function hide(el){
    if (!el) return;
    if (el.classList) el.classList.add('hidden', 'd-none');
    el.style && (el.style.display = 'none');
  }

  function getCurrentScale() {
    const m = getComputedStyle(pageEl).transform; // "matrix(a,b,c,d,tx,ty)" 또는 "none"
    if (!m || m === 'none') return 1;
    const nums = m.match(/matrix\(([^)]+)\)/);
    if (!nums) return 1;
    const parts = nums[1].split(',').map(parseFloat);
    const a = parts[0] || 1;
    return a || 1;
  }

  // 함께보기 버튼은 lg 이상에서만
  function updateSbsButtonVisibility() {
    if (window.innerWidth >= 1024) {
      show(btnSideBySide);
    } else {
      hide(btnSideBySide);
      if (mode === 'sbs') setMode('translated');
    }
  }

  async function loadOriginalImageIfNeeded() {
    if (originalLoaded) return;
    const dpi = (window.devicePixelRatio && window.devicePixelRatio >= 1.5) ? 192 : 144;
    const url = ORIGINAL_IMG_ENDPOINT + "?dpi=" + dpi;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error("original image url fetch failed: " + res.status);
    origImg.src = (await res.text()).trim();
    originalLoaded = true;
  }

  // -------- 레이아웃 모드 전환 --------
  function setMode(next) {
    mode = next;
    if (mode === 'sbs') {
      // 두 번째 뷰포트 준비
      ensureOrigViewport();
      // stage를 flex로 바꿔 두 뷰포트를 좌우 배치
      stageEl.style.display = 'flex';
      stageEl.style.gap = '2rem';
      stageEl.style.alignItems = 'flex-start';
      // 각 뷰포트 표시
      show(pageViewport);
      show(origViewport);
      // 페이지(번역/원본)는 각자 자기 뷰포트 내에 표시
      show(translatedPane);
      show(originalPane);
      // 버튼 텍스트
      btnToggleOriginal.textContent = "{% trans '번역본' %}";
      // 크기 동기화
      syncOrigSizeToTranslated();
    } else if (mode === 'original') {
      ensureOrigViewport();
      // 단일: 원본만 보이도록
      stageEl.style.display = ''; // 기본 흐름으로(기존 CSS에 맡김)
      hide(pageViewport);
      show(origViewport);
      show(originalPane);
      // 번역본은 가림
      hide(translatedPane);
      // 버튼 텍스트
      btnToggleOriginal.textContent = "{% trans '번역본' %}";
      // 크기 동기화
      syncOrigSizeToTranslated();
    } else {
      // 단일: 번역본만
      stageEl.style.display = '';
      show(pageViewport);
      hide(origViewport);
      show(translatedPane);
      hide(originalPane);
      btnToggleOriginal.textContent = "{% trans '원본 보기' %}";
    }
  }

  // 번역본 뷰포트의 현재 크기/배율을 읽어 원본 뷰포트/페이지에 반영
  function syncOrigSizeToTranslated() {
    if (!origViewport || !origPage) return;
    // 1) transform 동기화(#page → #origPage)
    const tr = getComputedStyle(pageEl).transform;
    origPage.style.transform = tr && tr !== 'none' ? tr : 'scale(1)';
    // 2) 뷰포트 크기 동기화(#pageViewport → #origViewport)
    //    (기존 확대/축소 스크립트가 pageViewport의 width/height를 관리하므로 그대로 복제)
    const pvStyle = getComputedStyle(pageViewport);
    origViewport.style.width  = pvStyle.width;
    origViewport.style.height = pvStyle.height;
    // 3) 내부 .page 크기/패딩은 기존 CSS에 따름. 필요하면 동일한 padding을 적용해도 됨.
  }

  // 확대/축소(= #page 스타일 변화)를 감지해서 원본 페이지에도 즉시 반영
  const mo = new MutationObserver(() => {
    if (mode !== 'translated') { // original / sbs에서만 동기화 필요
      syncOrigSizeToTranslated();
    }
  });
  mo.observe(pageEl, { attributes: true, attributeFilter: ['style'] });

  // 이벤트
  btnToggleOriginal.addEventListener('click', async () => {
    if (mode === 'translated') {
      try { await loadOriginalImageIfNeeded(); } catch(e){ console.error(e); alert("{% trans '원본 이미지를 불러오지 못했습니다.' %}"); return; }
      setMode('original');
    } else {
      setMode('translated');
    }
  });

  btnSideBySide.addEventListener('click', async () => {
    try { await loadOriginalImageIfNeeded(); } catch(e){ console.error(e); alert("{% trans '원본 이미지를 불러오지 못했습니다.' %}"); return; }
    setMode('sbs');
  });

  // 초기화
  (function init(){
    setMode('translated');            // 기본은 번역본만
    updateSbsButtonVisibility();      // 반응형 버튼 노출
    window.addEventListener('resize', debounce(() => {
      updateSbsButtonVisibility();
      if (mode !== 'translated') syncOrigSizeToTranslated();
    }, 120));
  })();

  function debounce(fn, wait){
    let t=null;
    return function(){ clearTimeout(t); t=setTimeout(fn, wait); };
  }
})();
</script>


{% endblock %}
