{% extends "page_base.html" %}
{% load static tailwind_tags i18n %}
{% load weaver_extras %}
{% block title %} {{ book.title }} - p{{ page_no }} {% endblock %}

{% block additional_head %}
<style>
  :root { --bg:#f9fafb; --ink:#111827; --muted:#6b7280; --top-margin: {{ css_vars|dict_get:'--top-margin' }}; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,sans-serif;}

  .wrap{max-width:100vw;margin:0 auto;padding:16px;}
  .toolbar{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap}
  .toolbar .group{display:flex;gap:8px;align-items:center}
  .toolbar button, .toolbar select{
    font:inherit;padding:6px 10px;border:1px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer}
  .toolbar button.active {
    background-color: #eef2ff; /* indigo-50 */
    border-color: #a5b4fc; /* indigo-200 */
    color: #4338ca; /* indigo-800 */
    font-weight: 600;
  }
  .toolbar button:hover{background:#f3f4f6}

  .stage{
    position:relative;
    overflow:auto;
    max-height: calc(100vh - 140px);
    display: flex;
    justify-content: center;
    align-items: flex-start; /* 페이지를 상단에 정렬 */
    padding: 20px 0; /* 뷰어의 상하 여백 */
  }
  .split-view {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    align-items: flex-start;
  }
  .pdf-viewer-container {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
    height: 100%;
    overflow: auto;
    padding: 20px 0;
  }
  #original-page-image {
    border: 1px solid #e5e7eb;
    max-width: 100%;
  }
  .page-viewport {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,.06);
    padding: 12px;
    box-sizing: border-box; /* padding을 너비/높이에 포함 */
    flex-shrink: 0; /* flex 아이템이 줄어들지 않도록 설정 */
  }

  .page{
    position:relative;
    width:{{ page_w }}px;
    height:{{ page_h }}px;
    transform-origin: top left;
  }

  /* v2 HTML stage 내부 기본 타이포 */
  .page :is(p,li){line-height:1.5}
  figure{margin:0.5rem 0;display:flex;flex-direction:column}
  figure img{max-width:100%;height:auto;border:1px solid #e5e7eb;border-radius:6px;background:#fff}
  figure figcaption{margin-top:.4rem;font-size:.9rem;color:var(--muted)}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #e5e7eb;padding:.5rem;vertical-align:top}

  .content div, .content p, .content div p {
      line-height: var(--leading);  
      margin-bottom: var(--para-gap);
  }
  .content {
    
    font-size: var(--font-base);
    padding: var(--pad);
    width: var(--content-w);
    height: var(--content-h);
    margin: 0 auto;
    padding-top: var(--top-margin);
  }
    
</style>
{% endblock %}

{% block content %}
<div id="translation-container" class="content" 
    style="
    --font-base: {{ css_vars|dict_get:'--font-base' }};
    --leading: {{ css_vars|dict_get:'--leading' }};
    --para-gap: {{ css_vars|dict_get:'--para-gap' }};
    --content-w: {{ css_vars|dict_get:'--content-w' }};
    --content-h: {{ css_vars|dict_get:'--content-h' }};
    --pad: {{ css_vars|dict_get:'--pad' }};
">
  {{ html_stage_final|safe }}
</div>

<div id="originalPane" class="d-none">
    <img id="origImg" alt="원본 페이지" style="max-width:100%;height:auto;border:1px solid #e5e7eb;border-radius:8px;">
</div>
{% endblock %}

{% block extra_js %}
<script>
(function(){
  const pageW = {{ page_w|default:800 }};
  const pageH = {{ page_h|default:1200 }};
  const stage  = document.getElementById('stage');
  if (!stage) return;
  const vp    = document.getElementById('pageViewport');
  const page   = document.getElementById('page');
  const zoomLabel = document.getElementById('zoomLabel');
  const fitWBtn = document.getElementById('fitW');
  const fitHBtn = document.getElementById('fitH');
  const zoomIn  = document.getElementById('zoomIn');
  const zoomOut = document.getElementById('zoomOut');

  let scale = 1.0;
  let zoomMode = 'fitWidth'; // 'fitWidth', 'fitHeight', 'custom' 중 하나를 저장
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const ZOOM_STATE_KEY = 'weaver_zoom_state'; // localStorage에 저장될 키

  // 현재 확대/축소 상태(비율과 모드)를 저장하는 함수
  function saveZoomState() {
    const state = { scale: scale, mode: zoomMode };
    localStorage.setItem(ZOOM_STATE_KEY, JSON.stringify(state));
  }

  function applyScale(newScale) {
    scale = clamp(newScale, 0.2, 3);
    page.style.transform = `scale(${scale})`;
    zoomLabel.textContent = Math.round(scale*100) + '%';

    const viewportPadding = 24;
    const scaledW = pageW * scale;
    const scaledH = pageH * scale;

    vp.style.width  = (scaledW + viewportPadding) + 'px';
    vp.style.height = (scaledH + viewportPadding) + 'px';
    stage.style.height = (scaledH + viewportPadding) + 'px';

    // 스케일이 적용될 때마다 상태를 저장합니다.
    saveZoomState();
  }
  
  function fitWidth(){
    zoomMode = 'fitWidth';
    const viewportPadding = 24;
    const availableWidth = stage.clientWidth;
    applyScale((availableWidth - viewportPadding) / pageW);
  }
  function fitHeight(){
    zoomMode = 'fitHeight';
    const pad = 24*2;
    const avail = (window.innerHeight - stage.getBoundingClientRect().top - 40) - pad;
    applyScale(avail / pageH);
  }

  fitWBtn.addEventListener('click', fitWidth);
  fitHBtn.addEventListener('click', fitHeight);
  zoomIn.addEventListener('click', () => {
    zoomMode = 'custom'; // 사용자가 직접 조절했음을 표시
    applyScale(scale * 1.1);
  });
  zoomOut.addEventListener('click', () => {
    zoomMode = 'custom'; // 사용자가 직접 조절했음을 표시
    applyScale(scale / 1.1);
  });
  window.addEventListener('resize', () => {
    // '가로 맞춤' 상태일 때만 창 크기 변경에 따라 너비를 다시 맞춥니다.
    if (zoomMode === 'fitWidth') {
      fitWidth();
    }
  });

  // 초기 뷰 설정: 저장된 확대/축소 상태가 있으면 복원합니다.
  (function initializeView() {
    try {
      const savedStateJSON = localStorage.getItem(ZOOM_STATE_KEY);
      if (savedStateJSON) {
          const savedState = JSON.parse(savedStateJSON);
          if (savedState && savedState.mode) {
              zoomMode = savedState.mode;
              if (zoomMode === 'fitWidth') { fitWidth(); return; }
              if (zoomMode === 'fitHeight') { fitHeight(); return; }
              if (zoomMode === 'custom' && typeof savedState.scale === 'number') { applyScale(savedState.scale); return; }
          }
      }
    } catch (e) {
      console.error("Failed to restore zoom state, using default.", e);
      localStorage.removeItem(ZOOM_STATE_KEY); // 손상된 데이터 제거
    }
    // 저장된 상태가 없거나 유효하지 않으면 기본값으로 시작합니다.
    fitWidth();
  })();
})();
</script>

<script>
/**
 * 원본보기 / 함께보기 (Option B: 페이지 이미지 캐싱)
 * - 번역본: #translation-container
 * - 원본:   #originalPane (내부 img#origImg)
 * - 버튼:   #btnToggleOriginal, #btnSideBySide
 * - 뷰모드: 'translated' | 'original' | 'sbs'
 * 
 * 핵심: 'sbs' 모드에서 #pageViewport 폭을 2장 기준으로 재계산해야
 *       오른쪽 원본이 실제로 보입니다.
 */
(function(){
  // -------- DOM --------
  const btnToggleOriginal = document.getElementById('btnToggleOriginal');
  const btnSideBySide     = document.getElementById('btnSideBySide');
  const translatedPane    = document.getElementById('translation-container');
  const originalPane      = document.getElementById('originalPane');
  const origImg           = document.getElementById('origImg');
  const pageEl            = document.getElementById('page');          // 확대/축소 transform 대상
  const pageViewport      = document.getElementById('pageViewport');  // 실제 크기 박스
  const stageEl           = document.getElementById('stage');         // 스크롤 컨테이너

  if (!btnToggleOriginal || !btnSideBySide || !translatedPane || !originalPane || !origImg || !pageEl || !pageViewport || !stageEl) {
    return;
  }

  // -------- 서버에서 내려줘야 하는 값 --------
  const bookId = {{ book.id }};
  const pageNo = {{ page_no }};

  // 두 장 레이아웃 계산에 사용할 기준 페이지 크기(확대/축소 전에)
  const BASE_PAGE_W = {{ page_w|default:800 }};
  const BASE_PAGE_H = {{ page_h|default:1200 }};

  // 엔드포인트: mybook:original_page_image(book_id, page_no)
  const ORIGINAL_IMG_ENDPOINT = "{% url 'mybook:original_page_image' book.id 1 %}".replace(/1\/original-image\/$/, pageNo + "/original-image/");

  // -------- 상태 --------
  let mode = 'translated'; // 'translated' | 'original' | 'sbs'
  let originalLoaded = false;

  // -------- 유틸 --------
  function show(el){ el.classList.remove('hidden','d-none'); }
  function hide(el){ el.classList.add('hidden','d-none'); }

  // 현재 scale을 #page의 transform 매트릭스에서 추정
  function getCurrentScale() {
    const m = getComputedStyle(pageEl).transform; // e.g. "matrix(a, b, c, d, tx, ty)"
    if (!m || m === 'none') return 1;
    const nums = m.match(/matrix\(([^)]+)\)/);
    if (!nums) return 1;
    const parts = nums[1].split(',').map(parseFloat);
    // a=parts[0], d=parts[3] (x,y 스케일)
    const a = parts[0] || 1, d = parts[3] || 1;
    // 비등방 스케일은 거의 없으니 a를 사용
    return a || 1;
  }

  // 함께보기 버튼 표시 정책(lg 이상)
  function updateSbsButtonVisibility() {
    if (window.innerWidth >= 1024) {
      show(btnSideBySide);
    } else {
      hide(btnSideBySide);
      if (mode === 'sbs') setMode('translated'); // 좁은 화면이면 sbs 강제 해제
    }
  }

  async function loadOriginalImageIfNeeded() {
    if (originalLoaded) return;
    const dpi = (window.devicePixelRatio && window.devicePixelRatio >= 1.5) ? 192 : 144;
    const url = ORIGINAL_IMG_ENDPOINT + "?dpi=" + dpi;
    const res = await fetch(url, { credentials: 'same-origin' });
    if (!res.ok) throw new Error("original image url fetch failed: " + res.status);
    origImg.src = (await res.text()).trim();
    originalLoaded = true;
  }

  // ***** 핵심: 모드에 맞춰 #pageViewport, #stage 크기 재계산 *****
  function adjustViewportForMode() {
    const scale = getCurrentScale();
    const pad = 24;               // 기존 확대 스크립트가 쓰는 여백과 일치
    const gap = 24;               // sbs 그리드 갭
    const oneW = BASE_PAGE_W * scale;
    const oneH = BASE_PAGE_H * scale;

    if (mode === 'sbs') {
      // 2장 + 갭 + 패딩
      const vw = Math.round(oneW * 2 + gap + pad);
      const vh = Math.round(oneH + pad);
      pageViewport.style.width  = vw + 'px';
      pageViewport.style.height = vh + 'px';
      stageEl.style.height      = vh + 'px';
    } else {
      // 단일 장(번역 또는 원본)
      const vw = Math.round(oneW + pad);
      const vh = Math.round(oneH + pad);
      pageViewport.style.width  = vw + 'px';
      pageViewport.style.height = vh + 'px';
      stageEl.style.height      = vh + 'px';
    }
  }

  // 확대/축소 스크립트가 #page 스타일을 바꿀 때(=transform 변경) 자동 추적
  const mo = new MutationObserver(() => {
    adjustViewportForMode();
  });
  mo.observe(pageEl, { attributes: true, attributeFilter: ['style'] });

  // 모드 전환
  function setMode(next) {
    mode = next;

    if (mode === 'sbs') {
      // 그리드 2열
      pageEl.style.display = 'grid';
      pageEl.style.gridTemplateColumns = '1fr 1fr';
      pageEl.style.columnGap = '24px';
      show(translatedPane);
      show(originalPane);
      btnToggleOriginal.textContent = "{% trans '번역본' %}";
    } else if (mode === 'original') {
      // 단일: 원본만
      pageEl.style.display = '';
      pageEl.style.gridTemplateColumns = '';
      hide(translatedPane);
      show(originalPane);
      btnToggleOriginal.textContent = "{% trans '번역본' %}";
    } else {
      // 단일: 번역본만
      pageEl.style.display = '';
      pageEl.style.gridTemplateColumns = '';
      show(translatedPane);
      hide(originalPane);
      btnToggleOriginal.textContent = "{% trans '원본 보기' %}";
    }

    // 모드 바뀔 때마다 뷰포트 보정
    adjustViewportForMode();
  }

  // 이벤트
  btnToggleOriginal.addEventListener('click', async () => {
    if (mode === 'translated') {
      try { await loadOriginalImageIfNeeded(); } catch(e){ console.error(e); alert("{% trans '원본 이미지를 불러오지 못했습니다.' %}"); return; }
      setMode('original');
    } else {
      setMode('translated');
    }
  });

  btnSideBySide.addEventListener('click', async () => {
    try { await loadOriginalImageIfNeeded(); } catch(e){ console.error(e); alert("{% trans '원본 이미지를 불러오지 못했습니다.' %}"); return; }
    setMode('sbs');
  });

  // 초기화
  (function init(){
    // 기본: 번역본
    setMode('translated');
    // 반응형 버튼 표시
    updateSbsButtonVisibility();
    window.addEventListener('resize', debounce(() => {
      updateSbsButtonVisibility();
      adjustViewportForMode();
    }, 120));

    // 혹시 초기 스케일이 적용된 상태라면 한 번 더 보정
    adjustViewportForMode();
  })();

  function debounce(fn, wait){
    let t=null;
    return function(){
      clearTimeout(t);
      t=setTimeout(fn, wait);
    }
  }
})();
</script>

{% endblock %}
