{% load static tailwind_tags i18n %}
<!DOCTYPE html>
<html lang={{ lang|default:'en' }}>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}BookWeaver - {% trans "언어의 장벽을 넘어 더 넓은 세상으로" %}{% endblock %}</title>
    {% block additional_head %}  {% endblock %}
    {# favicon #}
    <link rel="icon" type="image/svg+xml" href="{% static 'img/mikihands-favicon.svg' %}">
    <link rel="icon" sizes="16x16" href="{% static 'img/mikihands-favicon-16.png' %}" type="image/png">
    <link rel="icon" sizes="32x32" href="{% static 'img/mikihands-favicon-32.png' %}" type="image/png">
    <link rel="icon" sizes="48x48" href="{% static 'img/mikihands-favicon-48.png' %}" type="image/png">
    <link rel="apple-touch-icon" sizes="180x180" href="{% static 'img/mikihands-favicon-180.png' %}">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
    </style>
    <style>
        .page.edit-mode-active [id^="span-"],
        .page.edit-mode-active [id^="el-"],
        .page.edit-mode-active [id^="para-"] {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .page.edit-mode-active [id^="el-"] {
            position: relative;
        }
        /* 편집 모드에서 마우스를 올렸을 때의 스타일 */
        .page.edit-mode-active [id^="span-"]:hover,
        .page.edit-mode-active [id^="el-"]:hover,
        .page.edit-mode-active [id^="para-"]:hover {
            background-color: rgba(0, 123, 255, 0.2);
            outline: 1px dashed rgba(0, 123, 255, 0.7);
            z-index: 10; /* 다른 요소 위에 보이도록 z-index를 높게 설정 */
        }
        .span-editor-popover {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 16px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 280px;
        }
        .span-editor-popover label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
        }
        .span-editor-popover input {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            width: 120px;
        }
        .span-editor-popover input[type="text"] {
            width: 100%;
        }
        .span-editor-popover textarea {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            font-family: inherit;
        }
        .span-editor-popover .grid-inputs {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px;
        }
        /* 편집 모드에서 요소를 클릭했을 때의 스타일 */
        .span-selected {
            outline: 2px solid #007bff;
            background-color: rgba(0, 123, 255, 0.1);
        }
    </style>
    {% if not DEBUG_MODE %}
        {% tailwind_preload_css %}
    {% endif %}
    {% tailwind_css %}
</head>

<body>
    <nav class="bg-white shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex">
                    <a href="{% url 'mybook:upload_page' %}" class="flex-shrink-0 flex items-center font-bold text-xl gap-2">
                        <span class="inline-flex h-8 w-8 items-center justify-center rounded-lg bg-slate-900 text-white">W</span>
                        <span class="text-slate-900">BookWeaver</span>
                    </a>
                </div>
                <div class="flex items-center">
                    {% if request.user.is_authenticated and request.user.username %}
                        <div class="relative ml-3">
                            <div>
                                <button type="button" id="user-menu-button-page" class="flex items-center text-gray-500 hover:text-gray-700 focus:outline-none rounded-md text-sm font-medium" aria-expanded="false" aria-haspopup="true">
                                    <span class="sr-only">Open user menu</span>
                                    <span>{{ request.user.username }} {% if LANGUAGE_CODE == 'ko' %}님{% elif LANGUAGE_CODE == 'ja' %}様{% endif %}</span>
                                    <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                                </button>
                            </div>
                            <div id="user-menu-page" class="hidden origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 focus:outline-none z-50" role="menu" aria-orientation="vertical" aria-labelledby="user-menu-button-page">
                                <a href="{% url 'mybook:bookshelf' %}" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">{% trans "내 서재" %}</a>
                                <a href="{% url 'mybook:logout' %}" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">{% trans "로그아웃" %}</a>
                            </div>
                        </div>
                    {% else %}
                        <a href="{% url 'mybook:login_page' %}" class="text-gray-500 hover:text-gray-700 px-3 py-2 rounded-md text-sm font-medium">{% trans "로그인" %}</a>
                        <a href="{% url 'mybook:register_page' %}" class="ml-4 inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-blue-600 hover:bg-blue-700">
                            {% trans "회원가입" %}
                        </a>
                    {% endif %}
                </div>
            </div>
        </div>
    </nav>
    {# -- 1. 작업 실패 시 재시도 UI -- #}
    {% if book.status == 'failed' %}
    <div id="retry-banner" class="fixed top-20 right-5 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-lg z-50" role="alert">
      <strong class="font-bold">{% trans "번역 실패!" %}</strong>
      <span class="block sm:inline">{% trans "일부 페이지 번역에 실패했습니다." %}</span>
      <button id="retry-book-button" class="mt-2 bg-red-500 hover:bg-red-700 text-white font-bold py-1 px-3 rounded">
        {% trans "실패한 작업 재시도" %}
      </button>
      <button onclick="document.getElementById('retry-banner').style.display='none'" class="absolute top-0 bottom-0 right-0 px-4 py-3">
        <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
      </button>
    </div>
    {% endif %}

    <div class="wrap" id="weaver-root" style="font-size: calc(1rem * {{ base_font_scale|default:1 }})">

    <div class="toolbar">
        <div class="group">
        {% if prev_url %}<a href="{{ prev_url }}"><button>← {% trans "이전" %}</button></a>{% endif %}
        {% if next_url %}<a href="{{ next_url }}"><button>{% trans "다음" %} →</button></a>{% endif %}
        {% if book.page_count and book.page_count > 1 %}
        <form id="page-jump-form" class="flex items-center ml-2">
            <input type="number" id="page-jump-input" value="{{ page_no }}" min="1" max="{{ book.page_count }}" 
                   class="w-16 text-center border border-gray-300 rounded-md shadow-sm text-sm focus:ring-blue-500 focus:border-blue-500 py-1"
                   aria-label="{% trans '페이지 번호 입력' %}">
            <span class="mx-2 text-gray-500 text-sm">/ {{ book.page_count }}</span>
        </form>
        {% endif %}
        </div>

        <div class="group">
        <button id="fitW" {% if status != "ready" or not html_stage_final %}disabled class="disabled:opacity-50 disabled:cursor-not-allowed"{% endif %}>{% trans "맞춤(가로)" %}</button>
        <button id="fitH" {% if status != "ready" or not html_stage_final %}disabled class="disabled:opacity-50 disabled:cursor-not-allowed"{% endif %}>{% trans "맞춤(세로)" %}</button>
        <button id="zoomOut" {% if status != "ready" or not html_stage_final %}disabled class="disabled:opacity-50 disabled:cursor-not-allowed"{% endif %}>-</button>
        <span id="zoomLabel" style="color:#6b7280">100%</span>
        <button id="zoomIn" {% if status != "ready" or not html_stage_final %}disabled class="disabled:opacity-50 disabled:cursor-not-allowed"{% endif %}>+</button>
        </div>

        <div class="group">
            <label>{% trans "배경" %}:
                <select id="bgMode">
                <option value="auto" {% if bg_mode == "auto" %}selected{% endif %}>auto</option>
                <option value="on"   {% if bg_mode == "on" %}selected{% endif %}>on</option>
                <option value="off"  {% if bg_mode == "off" %}selected{% endif %}>off</option>
                </select>
            </label>
            
            <div class="flex items-center space-x-4 p-4">
                <button id="edit-mode-btn" class="px-4 py-2 bg-blue-500 rounded hover:bg-blue-600">
                    {% trans "편집 모드" %}
                </button>
                <button id="save-changes-btn" class="hidden px-4 py-2 bg-green-500 rounded hover:bg-green-600">
                    {% trans "변경 사항 저장" %}
                </button>
            </div>

            <button id="search-toggle-button" title="{% trans "책 안에서 검색" %}" class="p-2 rounded-md hover:bg-gray-100 ml-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
    </div>

    {% if status != "ready" or not html_stage_final %}
        <div id="status-banner" style="padding:24px;background:#fff7ed;border:1px solid #fdba74;color:#9a3412;border-radius:12px">
        {% if status == 'failed' %}
            {% trans "이 페이지 번역에 실패했습니다." %} (status={{ status }})
            <button id="retranslate-modal-button-inline" class="mt-2 bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded">
                {% trans "이 페이지 재번역" %}
            </button>
        {% else %}
            {% trans "이 페이지는 아직 처리 중이거나 준비되지 않았습니다." %} (status={{ status }})
        {% endif %}
        </div>
    {% else %}
        <div class="stage" id="stage">
            <div id="pageViewport" class="page-viewport">
                <div class="page" id="page">

                    {% block content %}
                    
                    {% endblock %}

                </div>
            </div>
        </div>
    {% endif %}
    </div>

    {# -- Search Side Panel -- #}
    <div id="search-panel" class="fixed top-0 -left-96 h-full w-96 bg-white shadow-2xl z-40 transition-all duration-300 ease-in-out flex flex-col">
        <!-- Header -->
        <div class="flex justify-between items-center p-4 border-b">
            <h2 class="text-xl font-semibold">{% trans "책 검색" %}</h2>
            <button id="search-panel-close" class="text-gray-500 hover:text-gray-800 text-2xl">&times;</button>
        </div>
        <!-- Search Input -->
        <div class="p-4 border-b">
            <form id="search-form">
                <input type="search" id="search-input" name="q" placeholder="{% trans '검색어 입력 후 Enter...' %}" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" required minlength="2">
            </form>
        </div>
        <!-- Results -->
        <div id="search-results-container" class="flex-grow overflow-y-auto">
            <div id="search-results-list" class="divide-y"></div>
            <div id="search-message" class="p-6 text-center text-gray-500">
                {% trans "검색어를 입력하고 Enter를 누르세요." %}
            </div>
        </div>
    </div>
    <div id="search-panel-overlay" class="hidden fixed inset-0 bg-black/50 z-30"></div>

    {# -- 2. 페이지 재번역 요청 UI (버튼 및 모달) -- #}
    <div class="fixed bottom-5 right-5 z-50">
        <button id="retranslate-modal-button-float" title="이 페이지 재번역 요청" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-3 rounded-full shadow-lg flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 20h5v-5M20 4h-5v5" /></svg>
        </button>
    </div>

    <div id="retranslate-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50 hidden">
      <div class="relative top-20 mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white">
        <div class="mt-3 text-center">
          <h3 class="text-lg leading-6 font-medium text-gray-900">{% trans "페이지" %} {{ page_no }} {% trans "재번역 요청" %}</h3>
          <div class="mt-2 px-7 py-3">
            <p class="text-sm text-gray-500 mb-4">{% trans "번역이 어색하거나 잘못된 부분을 구체적으로 알려주세요." %} ({% trans "예: Kipper는 어린이입니다. 아이말투로 바꿔주세요." %})</p>
            <textarea id="retranslate-feedback" class="w-full h-24 p-2 border rounded" placeholder="{% trans '피드백을 입력하세요... (선택 사항)' %}"></textarea>
          </div>
          <div class="items-center px-4 py-3">
            <button id="submit-retranslate" class="px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md w-full shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300">
              {% trans "요청하기" %}
            </button>
            <button id="close-retranslate-modal" class="mt-2 px-4 py-2 bg-gray-200 text-gray-800 text-base font-medium rounded-md w-full shadow-sm hover:bg-gray-300">
              {% trans "취소" %}
            </button>
          </div>
        </div>
      </div>
    </div>

    {% block extra_js %}{% endblock %}
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // CSRF 토큰 가져오기
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.startsWith(name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // --- 사용자 메뉴 드롭다운 로직 ---
        const userMenuButtonPage = document.getElementById('user-menu-button-page');
        const userMenuPage = document.getElementById('user-menu-page');

        if (userMenuButtonPage && userMenuPage) {
            userMenuButtonPage.addEventListener('click', function() {
                userMenuPage.classList.toggle('hidden');
            });

            // Close the dropdown if the user clicks outside of it
            window.addEventListener('click', function(event) {
                if (!userMenuButtonPage.contains(event.target) && !userMenuPage.contains(event.target)) {
                    userMenuPage.classList.add('hidden');
                }
            });
        }

        // --- 페이지 점프 기능 로직 ---
        const pageJumpForm = document.getElementById('page-jump-form');
        const pageJumpInput = document.getElementById('page-jump-input');

        if (pageJumpForm && pageJumpInput) {
            // 입력 필드를 클릭하면 내용 전체 선택
            pageJumpInput.addEventListener('focus', function() {
                this.select();
            });

            pageJumpForm.addEventListener('submit', function(event) {
                event.preventDefault();
                const targetPage = parseInt(pageJumpInput.value, 10);
                const maxPage = parseInt(pageJumpInput.getAttribute('max'), 10);

                if (!isNaN(targetPage) && targetPage >= 1 && targetPage <= maxPage) {
                    const currentUrl = new URL(window.location.href);
                    const pathParts = currentUrl.pathname.split('/');
                    pathParts[pathParts.length - 2] = targetPage; 
                    currentUrl.pathname = pathParts.join('/');
                    window.location.href = currentUrl.toString();
                } else {
                    alert(`{% blocktrans %}1에서 {{ maxPage }} 사이의 유효한 페이지 번호를 입력하세요.{% endblocktrans %}`);
                    pageJumpInput.value = {{ page_no }};
                    pageJumpInput.select();
                }
            });
        }

        // --- 페이지 번역 상태 폴링 로직 ---
        const bookId = {{ book.id }};
        const pageNo = {{ page_no }};
        const currentStatus = '{{ status }}';
        
        // --- 페이지 번역 상태 폴링 로직 ---
        if (currentStatus !== 'ready' && currentStatus !== 'failed') {
            const statusBanner = document.getElementById('status-banner');
            if (statusBanner) {
                const pollingIndicator = document.createElement('div');
                pollingIndicator.id = 'polling-indicator';
                pollingIndicator.className = 'mt-2 text-sm text-gray-600';
                pollingIndicator.textContent = '{% trans "번역 상태를 확인 중입니다... (완료 시 자동 새로고침)" %}';
                statusBanner.appendChild(pollingIndicator);
            }

            const poll = (url, interval, maxAttempts) => {
                let attempts = 0;
                const executePoll = async (resolve, reject) => {
                    if (attempts++ >= maxAttempts) {
                        return reject(new Error('Polling timed out.'));
                    }
                    try {
                        const response = await fetch(url);
                        if (!response.ok) {
                            if (response.status === 403) {
                                alert("{% trans '인증에 실패했습니다. 다시 로그인해주세요.' %}");
                            }
                            return reject(new Error(`Status check failed with status: ${response.status}`));
                        }
                        const data = await response.json();

                        if (data.status === 'ready' || data.status === 'failed') {
                            return resolve(data.status);
                        } else {
                            setTimeout(() => executePoll(resolve, reject), interval);
                        }
                    } catch (error) {
                        return reject(error);
                    }
                };
                return new Promise(executePoll);
            };

            const statusUrl = `/books/${bookId}/pages/${pageNo}/status/?mode={{ request.GET.mode|default:'faithful' }}{% if lang %}&lang={{ lang }}{% endif %}`;
            
            poll(statusUrl, 3000, 40) // 3초마다, 최대 2분간 확인
                .then(finalStatus => {
                    console.log(`Polling finished with status: ${finalStatus}`);
                    const indicator = document.getElementById('polling-indicator');
                    if (indicator) {
                        indicator.textContent = '{% trans "번역이 완료되었습니다. 페이지를 새로고침합니다..." %}';
                        indicator.className = 'mt-2 text-sm text-green-700 font-bold';
                    }
                    setTimeout(() => window.location.reload(), 500);
                })
                .catch(error => {
                    console.error('Polling failed:', error.message);
                });
        }

        // --- 검색 기능 및 하이라이트 로직 ---
        if (bookId) {
            const searchToggleButton = document.getElementById('search-toggle-button');
            const searchPanel = document.getElementById('search-panel');
            const searchPanelClose = document.getElementById('search-panel-close');
            const searchPanelOverlay = document.getElementById('search-panel-overlay');
            const searchForm = document.getElementById('search-form');
            const searchInput = document.getElementById('search-input');
            const searchResultsList = document.getElementById('search-results-list');
            const searchMessage = document.getElementById('search-message');
            const contentContainer = document.querySelector('.content');

            function openSearchPanel() {
                searchPanel.classList.remove('-left-96');
                searchPanel.classList.add('left-0');
                searchPanelOverlay.classList.remove('hidden');
                searchInput.focus();
            }

            function closeSearchPanel() {
                searchPanel.classList.add('-left-96');
                searchPanel.classList.remove('left-0');
                searchPanelOverlay.classList.add('hidden');
            }

            searchToggleButton.addEventListener('click', openSearchPanel);
            searchPanelClose.addEventListener('click', closeSearchPanel);
            searchPanelOverlay.addEventListener('click', closeSearchPanel);

            searchForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const query = searchInput.value.trim();
                if (query.length < 2) {
                    searchMessage.textContent = '{% trans "검색어는 2글자 이상 입력해주세요." %}';
                    return;
                }

                searchResultsList.innerHTML = '';
                searchMessage.innerHTML = '<div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600 mx-auto mt-8"></div>';
                searchMessage.classList.remove('hidden');

                try {
                    const response = await fetch(`/books/${bookId}/search/?q=${encodeURIComponent(query)}`);
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error || '{% trans "검색 중 오류가 발생했습니다." %}');
                    }
                    const results = await response.json();

                    if (results.length === 0) {
                        searchMessage.textContent = `{% blocktrans %}'${query}'에 대한 검색 결과가 없습니다.{% endblocktrans %}`;
                    } else {
                        searchMessage.classList.add('hidden');
                        results.forEach(result => {
                            const resultEl = document.createElement('a');
                            const currentUrlParams = new URLSearchParams(window.location.search);
                            currentUrlParams.set('highlight', query);
                            resultEl.href = `/books/${bookId}/pages/${result.page_no}/?${currentUrlParams.toString()}`;
                            resultEl.className = 'block p-4 hover:bg-gray-50 cursor-pointer';
                            resultEl.innerHTML = `<div class="font-bold text-blue-600">Page ${result.page_no}</div><div class="text-sm text-gray-600 mt-1">${result.snippet}</div>`;
                            searchResultsList.appendChild(resultEl);
                        });
                    }
                } catch (error) {
                    searchMessage.textContent = error.message;
                }
            });

            // --- Highlight on Page Load ---
            function applyHighlight() {
                const params = new URLSearchParams(window.location.search);
                const highlightQuery = params.get('highlight');
                if (!highlightQuery || !contentContainer) return;

                const re = new RegExp(`(${highlightQuery.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')})`, 'gi');
                const walker = document.createTreeWalker(contentContainer, NodeFilter.SHOW_TEXT);
                const nodes = [];
                while(walker.nextNode()) if(re.test(walker.currentNode.nodeValue)) nodes.push(walker.currentNode);
                nodes.forEach(node => {
                    const newHtml = node.nodeValue.replace(re, '<mark class="bg-yellow-300 px-1 rounded-sm">$1</mark>');
                    node.parentNode.replaceChild(document.createRange().createContextualFragment(newHtml), node);
                });
            }
            applyHighlight();
        }

        // 책 전체 재시도 버튼 로직
        const retryBookButton = document.getElementById('retry-book-button');
        if (retryBookButton) {
            retryBookButton.addEventListener('click', async () => {
                retryBookButton.textContent = '{% trans "요청 중..." %}';
                retryBookButton.disabled = true;
                try {
                    const response = await fetch(`/books/{{ book.id }}/retry/`, {
                        method: 'POST',
                        headers: { 'X-CSRFToken': csrftoken, 'Content-Type': 'application/json' },
                    });
                    const data = await response.json();
                    if (!response.ok && response.status === 403 && data.detail === "Authentication credentials were not provided.") {
                        alert('{% trans "로그인이 필요합니다." %}');
                        window.location.href = "{% url 'mybook:login_page' %}";
                        return;
                    }
                    alert(data.message || data.error);
                    if (response.ok) window.location.reload();
                } catch (e) {
                    alert('{% trans "네트워크 오류가 발생했습니다." %}');
                } finally {
                    retryBookButton.textContent = '{% trans "실패한 작업 전체 재시도" %}';
                    retryBookButton.disabled = false;
                }
            });
        }

        // 재번역 모달 로직
        const modal = document.getElementById('retranslate-modal');
        const openModalButtons = document.querySelectorAll('#retranslate-modal-button-float, #retranslate-modal-button-inline');
        const closeModalBtn = document.getElementById('close-retranslate-modal');
        const submitBtn = document.getElementById('submit-retranslate');

        openModalButtons.forEach(btn => btn.onclick = () => modal.style.display = 'block');
        closeModalBtn.onclick = () => modal.style.display = 'none';
        window.onclick = (event) => {
            if (event.target == modal) modal.style.display = 'none';
        };

        submitBtn.addEventListener('click', async () => {
            const feedback = document.getElementById('retranslate-feedback').value;

            submitBtn.textContent = '{% trans "요청 중..." %}';
            submitBtn.disabled = true;

            try {
                const response = await fetch('{% url "mybook:retranslate_page" book_id=book.id page_no=page_no %}{% if lang %}?lang={{ lang }}{% endif %}', {
                    method: 'POST',
                    headers: { 'X-CSRFToken': csrftoken, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ feedback: feedback || "Retranslate this page." }) // 피드백이 없으면 기본 메시지
                });
                const data = await response.json();
                if (!response.ok && response.status === 403 && data.detail === "Authentication credentials were not provided.") {
                    alert('{% trans "로그인이 필요합니다." %}');
                    window.location.href = "{% url 'mybook:login_page' %}";
                    return;
                }
                alert(data.message || data.error);
                if (response.ok) {
                    modal.style.display = 'none';
                    setTimeout(() => window.location.reload(), 1500);
                }
            } catch (e) {
                alert('{% trans "네트워크 오류가 발생했습니다." %}');
            } finally {
                submitBtn.textContent = '{% trans "요청하기" %}';
                submitBtn.disabled = false;
            }
        });
    });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const editModeBtn = document.getElementById('edit-mode-btn');
            const saveChangesBtn = document.getElementById('save-changes-btn');
            const pageContainer = document.querySelector('.page');
            const processingMode = "{{ book.processing_mode }}";

            let isInEditMode = false;
            let changes = {}; // { elementId: { style, text } }
            let currentEditor = null;
            let selectedElement = null;

            // 편집할 내용이 없으면 버튼 숨김
            if (!pageContainer) {
                if(editModeBtn) editModeBtn.style.display = 'none';
                return;
            }

            editModeBtn.addEventListener('click', toggleEditMode);
            saveChangesBtn.addEventListener('click', saveChanges);

            function toggleEditMode() {
                isInEditMode = !isInEditMode;
                pageContainer.classList.toggle('edit-mode-active', isInEditMode);
                editModeBtn.textContent = isInEditMode ? '{% trans "편집 모드 종료" %}' : '{% trans "편집 모드" %}';
                saveChangesBtn.style.display = isInEditMode ? 'inline-block' : 'none';

                if (isInEditMode) {
                    setupEditableElementListeners();
                } else {
                    removeEditableElementListeners();
                    removeEditor();
                }
            }

            function getEditableElementSelector() {
                // born_digital과 ai_layout 모두 문단 단위의 div를 편집 대상으로 통일합니다.
                return '[id^="para-"]';
            }

            function setupEditableElementListeners() {
                const selector = getEditableElementSelector();
                pageContainer.querySelectorAll(selector).forEach(el => {
                    el.addEventListener('click', handleElementClick);
                });
            }

            function removeEditableElementListeners() {
                const selector = getEditableElementSelector();
                pageContainer.querySelectorAll(selector).forEach(el => {
                    el.removeEventListener('click', handleElementClick);
                });
            }

            function handleElementClick(event) {
                if (!isInEditMode) return;
                event.stopPropagation();
                const element = event.currentTarget;
                
                if (selectedElement) {
                    selectedElement.classList.remove('span-selected');
                }
                selectedElement = element;
                selectedElement.classList.add('span-selected');

                showEditorForElement(element);
            }

            // CSS 값과 단위를 분리하는 헬퍼 함수
            function parseCssValue(valueStr) {
                if (typeof valueStr !== 'string') return { value: 0, unit: '' };
                const match = valueStr.trim().match(/^(-?[\d.]+)(.*)$/);
                if (match) {
                    return { value: parseFloat(match[1]), unit: match[2].trim() || '' };
                }
                return { value: 0, unit: '' };
            }

            function showEditorForElement(element) {
                removeEditor();

                const rect = element.getBoundingClientRect();
                const editor = document.createElement('div');
                editor.className = 'span-editor-popover';
                
                // born_digital과 ai_layout 모드 모두 새로운 UI를 사용하도록 통일합니다.
                // ai_layout 모드는 CSS 변수를 사용하지만, born_digital은 절대 px 값을 사용합니다.
                // getComputedStyle을 사용하면 두 경우 모두 현재 렌더링된 값을 가져올 수 있습니다.
                if (processingMode === 'ai_layout') {
                    // --- ai_layout용 UI (CSS 변수 기반) ---
                    const originalStyleAttr = element.getAttribute('style') || '';
                    const computedStyle = getComputedStyle(element);
                    const contentDiv = element.closest('.content');
                    const baseFontSize = contentDiv ? parseFloat(getComputedStyle(contentDiv).fontSize) : 16;

                    // 1. Font Size Multiplier
                    let currentFontSizeMultiplier = 1.0;
                    const fsMatch = originalStyleAttr.match(/font-size:\s*calc\(var\(--font-base\)\s*\*\s*([\d.-]+)\)/);
                    if (fsMatch) {
                        currentFontSizeMultiplier = parseFloat(fsMatch[1]);
                    } else {
                        currentFontSizeMultiplier = (parseFloat(computedStyle.fontSize) / baseFontSize).toFixed(2);
                    }

                    // 2. Line Height
                    let currentLineHeight = 1.5;
                    const lhMatch = originalStyleAttr.match(/line-height:\s*([\d.]+)/);
                    if (lhMatch) {
                        currentLineHeight = parseFloat(lhMatch[1]);
                    } else if (computedStyle.lineHeight !== 'normal') {
                        const { value: lhValue, unit: lhUnit } = parseCssValue(computedStyle.lineHeight);
                        currentLineHeight = (lhUnit === 'px') ? (lhValue / parseFloat(computedStyle.fontSize)).toFixed(2) : lhValue;
                    }

                    // 3. Text Align
                    const currentTextAlign = computedStyle.textAlign;

                    // 4. Margin Top/Bottom Multiplier
                    let currentMarginTopMultiplier = 0;
                    const mtMatch = originalStyleAttr.match(/margin-top:\s*calc\(var\(--font-base\)\s*\*\s*([\d.-]+)\)/);
                    if (mtMatch) {
                        currentMarginTopMultiplier = parseFloat(mtMatch[1]);
                    } else if (computedStyle.marginTop !== '0px') {
                        currentMarginTopMultiplier = (parseFloat(computedStyle.marginTop) / baseFontSize).toFixed(2);
                    }

                    let currentMarginBottomMultiplier = 0;
                    const mbMatch = originalStyleAttr.match(/margin-bottom:\s*calc\(var\(--font-base\)\s*\*\s*([\d.-]+)\)/);
                    if (mbMatch) {
                        currentMarginBottomMultiplier = parseFloat(mbMatch[1]);
                    } else if (computedStyle.marginBottom !== '0px') {
                        currentMarginBottomMultiplier = (parseFloat(computedStyle.marginBottom) / baseFontSize).toFixed(2);
                    }

                    editor.innerHTML = `
                        
                        <div>
                            <label for="text-editor" class="block text-sm font-medium text-gray-700 mb-1">Text</label>
                            <textarea id="text-editor" rows="3" class="w-full border border-gray-300 rounded-md p-2 text-sm">${element.textContent}</textarea>
                        </div>
                        <div class="grid-inputs flex flex-col gap-8">
                            <label>Font Size:</label> <input type="number" step="0.05" value="${currentFontSizeMultiplier}" data-style-prop="font-size">
                            <label>Line Height:</label> <input type="number" step="0.1" value="${currentLineHeight}" data-style-prop="line-height">
                            <label>Margin Top:</label> <input type="number" step="0.1" value="${currentMarginTopMultiplier}" data-style-prop="margin-top">
                            <label>Margin Bottom:</label> <input type="number" step="0.1" value="${currentMarginBottomMultiplier}" data-style-prop="margin-bottom">
                            <label>Text Align: </label>
                            <select data-style-prop="text-align" class="border rounded px-1 py-0.5">
                                <option value="left" ${currentTextAlign === 'left' ? 'selected' : ''}>Left</option>
                                <option value="center" ${currentTextAlign === 'center' ? 'selected' : ''}>Center</option>
                                <option value="right" ${currentTextAlign === 'right' ? 'selected' : ''}>Right</option>
                                <option value="justify" ${currentTextAlign === 'justify' ? 'selected' : ''}>Justify</option>
                            </select>
                        </div>
                    `;

                    editor.addEventListener('input', (e) => {
                        const target = e.target;
                        if (target.id === 'text-editor') {
                            element.textContent = target.value;
                        } else {
                            // 스타일 변경 시, 전체 스타일 속성을 재구성
                            const fsInput = editor.querySelector('[data-style-prop="font-size"]');
                            const lhInput = editor.querySelector('[data-style-prop="line-height"]');
                            const taInput = editor.querySelector('[data-style-prop="text-align"]');
                            const mtInput = editor.querySelector('[data-style-prop="margin-top"]');
                            const mbInput = editor.querySelector('[data-style-prop="margin-bottom"]');

                            const currentStyles = new Map();
                            (element.getAttribute('style') || '').split(';').forEach(style => {
                                if (style.trim()) {
                                    const [prop, value] = style.split(/:(.*)/s);
                                    if (prop && value) currentStyles.set(prop.trim(), value.trim());
                                }
                            });

                            // 에디터 값으로 스타일 맵 업데이트
                            currentStyles.set('font-size', `calc(var(--font-base) * ${fsInput.value})`);
                            currentStyles.set('line-height', `${lhInput.value}`);
                            currentStyles.set('text-align', `${taInput.value}`);
                            currentStyles.set('margin-top', `calc(var(--font-base) * ${mtInput.value})`);
                            currentStyles.set('margin-bottom', `calc(var(--font-base) * ${mbInput.value})`);
                            
                            // 개별 마진 설정 시, 축약형 margin 속성 제거
                            currentStyles.delete('margin');

                            const newStyleString = Array.from(currentStyles.entries()).map(([p, v]) => `${p}: ${v}`).join('; ');
                            element.setAttribute('style', newStyleString);
                        }
                        recordChange(element);
                    });                    
                } else {
                    // --- born_digital용 UI (절대 px 값 기반) ---
                    const computedStyle = getComputedStyle(element);
                    const currentLeft = parseFloat(computedStyle.left);
                    const currentTop = parseFloat(computedStyle.top);
                    const currentFontSize = parseFloat(computedStyle.fontSize);
                    const currentWidth = parseFloat(computedStyle.width);
                    const currentLineHeight = parseFloat(computedStyle.lineHeight) / currentFontSize; // 상대값으로 변환
                    const currentTextAlign = computedStyle.textAlign;

                    editor.innerHTML = `
                        <div>
                            <label for="text-editor" class="block text-sm font-medium text-gray-700 mb-1">Text</label>
                            <textarea id="text-editor" rows="3" class="w-full border border-gray-300 rounded-md p-2 text-sm">${element.textContent}</textarea>
                        </div>
                        <div class="grid-inputs flex flex-col gap-8">
                            <label>Left (px):</label> <input type="number" step="0.1" value="${currentLeft.toFixed(2)}" data-style-prop="left">
                            <label>Top (px):</label> <input type="number" step="0.1" value="${currentTop.toFixed(2)}" data-style-prop="top">
                            <label>Font Size (px):</label> <input type="number" step="0.1" value="${currentFontSize.toFixed(2)}" data-style-prop="font-size">
                            <label>Width (px):</label> <input type="number" step="1" value="${currentWidth.toFixed(0)}" data-style-prop="width">
                            <label>Line Height:</label> <input type="number" step="0.1" value="${currentLineHeight.toFixed(2)}" data-style-prop="line-height">
                            <label>Text Align:</label>
                            <select data-style-prop="text-align" class="border rounded px-1 py-0.5">
                                <option value="left" ${currentTextAlign === 'left' ? 'selected' : ''}>Left</option>
                                <option value="center" ${currentTextAlign === 'center' ? 'selected' : ''}>Center</option>
                                <option value="right" ${currentTextAlign === 'right' ? 'selected' : ''}>Right</option>
                                <option value="justify" ${currentTextAlign === 'justify' ? 'selected' : ''}>Justify</option>
                            </select>
                        </div>
                    `;

                    editor.addEventListener('input', (e) => {
                        const target = e.target;
                        if (target.id === 'text-editor') {
                            element.textContent = target.value;
                        } else if (target.dataset.styleProp) {
                            const prop = target.dataset.styleProp;
                            const unit = ['left', 'top', 'font-size', 'width'].includes(prop) ? 'px' : '';
                            element.style[prop] = `${target.value}${unit}`;
                        }
                        recordChange(element);
                    });
                }


                // 툴박스를 화면에 추가하기 전에 먼저 높이를 측정합니다.
                // 보이지 않게 추가하여 크기를 계산한 후, 올바른 위치를 잡습니다.
                editor.style.visibility = 'hidden';
                document.body.appendChild(editor);
                const editorHeight = editor.offsetHeight;

                // 툴박스를 표시할 최적의 y축 위치를 계산합니다.
                let topPosition;
                const spaceBelow = window.innerHeight - rect.bottom;
                const spaceAbove = rect.top;

                // 아래쪽 공간이 부족하고 위쪽 공간이 더 많으면, 툴박스를 요소의 위에 표시합니다.
                if (spaceBelow < (editorHeight + 10) && spaceAbove > spaceBelow) {
                    topPosition = window.scrollY + rect.top - editorHeight - 5;
                } else {
                    // 그렇지 않으면, 기존처럼 아래에 표시합니다.
                    topPosition = window.scrollY + rect.bottom + 5;
                }

                editor.style.left = `${window.scrollX + rect.left}px`;
                editor.style.top = `${Math.max(window.scrollY, topPosition)}px`; // 페이지 상단 밖으로 나가지 않도록 보정
                editor.style.visibility = 'visible'; // 이제 툴박스를 보이게 합니다.

                currentEditor = editor;
            }

            function recordChange(element) {
                changes[element.id] = {
                    style: element.getAttribute('style'),
                    text: element.textContent
                };
            }

            function removeEditor() {
                if (currentEditor) {
                    currentEditor.remove(); // 편집기 팝업만 제거
                    currentEditor = null; 
                }
                if (selectedElement) {
                    // // 선택된 요소에서 핸들 제거 (핸들 기능 제거됨)
                    // const handle = selectedElement.querySelector('.resize-handle');
                    // if (handle) handle.remove();

                    selectedElement.classList.remove('span-selected');
                    // selectedElement를 null로 만들어, 외부 클릭 시에도 정상 작동하도록 함
                    selectedElement = null;
                }
            }
            

            function saveChanges() {
                if (Object.keys(changes).length === 0) {
                    alert('{% trans "변경된 내용이 없습니다." %}');
                    return;
                }

                // URL 쿼리 파라미터에서 lang과 mode를 직접 읽어옵니다.
                // 이렇게 하면 템플릿 변수가 비어있는 경우에도 정확한 값을 사용할 수 있습니다.
                const urlParams = new URLSearchParams(window.location.search);
                const currentLang = urlParams.get('lang') || "{{ lang }}"; // URL에 없으면 템플릿 변수로 폴백
                const currentMode = urlParams.get('mode') || "{{ mode }}"; // URL에 없으면 템플릿 변수로 폴백

                const payload = {
                    lang: currentLang,
                    mode: currentMode,
                    changes: Object.entries(changes).map(([element_id, data]) => ({
                        element_id,
                        style: data.style,
                        text: data.text
                    }))
                };

                fetch("{% url 'mybook:edit_book_page' book.id page_no %}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrftoken}}'
                    },
                    body: JSON.stringify(payload)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw new Error(err.error || 'Server error') });
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.message) {
                        alert('{% trans "변경 사항이 성공적으로 저장되었습니다." %}');
                        changes = {}; // 변경사항 초기화
                        toggleEditMode(); // 편집 모드 종료
                    } else {
                        throw new Error(data.error || '저장에 실패했습니다.');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert(`{% trans "오류" %}: ${error.message}`);
                });
            }

            // --- 자동 겹침 보정 로직 (페이지 로드 시 1회 실행) ---
            function autoAdjustOverlaps() {
                if (processingMode !== 'born_digital' || !pageContainer) return;

                const paras = Array.from(pageContainer.querySelectorAll('[id^="para-"]'))
                    .sort((a, b) => parseFloat(a.style.top) - parseFloat(b.style.top));

                for (let i = 0; i < paras.length; i++) {
                    const current = paras[i];

                    // 현재 페이지의 scale 값을 매번 다시 가져옵니다 (동적 변경 가능성)
                    const transform = window.getComputedStyle(pageContainer).transform;
                    const scale = (transform && transform !== 'none') ? new DOMMatrix(transform).a : 1.0;
                    
                    const currentRect = current.getBoundingClientRect();

                    // 백엔드에서 전달받은 '허용 높이'
                    const allowedHeight = parseFloat(current.dataset.allowedHeight);

                    // 단순화된 로직:
                    // 1. '허용 높이' 속성이 있고 (원래 한 줄이었던 요소)
                    // 2. 실제 렌더링된 높이가 허용 높이보다 크다면 (줄바꿈이 일어났다면)
                    if (allowedHeight && (currentRect.height / scale > allowedHeight + 1)) {
                        // 강제로 한 줄로 표시하도록 스타일 변경
                        current.style.whiteSpace = 'pre';
                    }
                }
            }

            // 편집기 외부 클릭 시 편집기 닫기 (이벤트 리스너를 여기에 한번만 등록)
            document.addEventListener('click', (e) => {
                if (isInEditMode && currentEditor && !currentEditor.contains(e.target) && !e.target.closest(getEditableElementSelector())) {
                    removeEditor();
                }
            });

            // DOMContentLoaded 대신 window.onload를 사용하여 폰트 로딩 후 실행
            window.addEventListener('load', () => {
                autoAdjustOverlaps();
            });
        });
    </script>
</body>
</html>
